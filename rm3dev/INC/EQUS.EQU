$SAVE NOLIST

;---FILE HEADER-(set tabulator to 8)-------------------------------------------
;
;   filename	: EQUS.EQU
;   version	: 0005
;   contents	: RMOS system symbols
;   author	: K.P.H.
;   date	: Jan 13, 1996
;
;---FUNCTION AND RMOS ENVIRONMENT----------------------------------------------
;
;   function	: Symbolic constants for Nucleus
;
;   RMOS2 & RMOS3 
;
;---END	OF FILE	HEADER---------------------------------------------------------
;
;---MODIFICATION HEADER--------------------------------------------------------
;
;   Jan 19, 1995  K.P.H. 0001  Original issue, changes for new RMOS version
;   Mar 08, 1995  K.P.H. 0002  Additional changes for RMOS2
;   Aug 02, 1995  K.P.H. 0003  Modification for RMOS V3.12
;   Jan 13, 1995  K.P.H. 0004  Additional modification for RMOS V3.12
;   Jul 13, 2001  B.N.   0005  new Flag introduced
;
;---END	OF MODIFICATION	HEADER-------------------------------------------------

;  THE FOLLOWING SYMBOL	DEFINITIONS ARE	USED WIDELY THROUGH RMOS. THEY	
;DEFINE	ALL THE	SYSTEM'S INTERNAL DATA STRUCTURES. ANY CHANGE TO ANY ONE OF
;THEM SHOULD BE	FOLLOWED BY THE	REASSEMBLY OF THE ENTIRE SYSTEM, TO INSURE
;THAT THE NEW DEFINITIONS ARE OBSERVED IN ALL APPLICABLE PLACES.

;------------------------------------------------------------------------------
;   NUCLEUS DEFINITIONS
;------------------------------------------------------------------------------
;
;   TCD: TASK CONTROL DEFINITION BLOCK.
;
%IF(%RM3)THEN(			
TCD_EAX		EQU	0		;STARTUP PARAMETER 1
TCD_EBX		EQU	TCD_EAX	  +4	;STARTUP PARAMETER 2
TCD_DS		EQU	TCD_EBX	  +4	;STARTUP DS
TCD_ES		EQU	TCD_DS	  +2	;STARTUP ES
TCD_ESP		EQU	TCD_ES	  +2	;STARTUP SP
TCD_SS		EQU	TCD_ESP	  +4	;STARTUP SS
TCD_EIP		EQU	TCD_SS	  +2	;ENTRY POINT OFFSET
TCD_CS		EQU	TCD_EIP	  +4	;ENTRY POINT SEGMENT
TCD_LOAD	EQU	TCD_CS	  +2	;RESERVED
TCD_TIME	EQU	TCD_LOAD  +6	;OVERRIDE TIME:	UNIT, NUMBER OF	UNITS.
TCD_OVPRI	EQU	TCD_TIME  +2	;OVERRIDE PRIORITY INCREMENT.
TCD_BPRI	EQU	TCD_OVPRI +1	;BOUNDARY ON PRIORITY OVERRIDES.
TCD_INPRI	EQU	TCD_BPRI  +1	;INHERENT PRIORITY
TCD_PID		EQU	TCD_INPRI +1	;RESERVED
TCD_FLAGS	EQU	TCD_PID	  +1	;TASK FLAG WORD: SEE TCB_FLAGS.
TCD_RR_TICKS	EQU	TCD_FLAGS +2	;TASK SPECIFIC ROUND ROBIN COUNT
					;IF X_RR_BOUND IS 0FFFFH.
TCD_EFG		EQU	TCD_RR_TICKS+2	;LOCAL EVENTFLAG GROUP
TCD_RES		EQU	TCD_EFG   +8	;RESERVED,HAS TO BE 0 FOR TCB DETECTION
TCD_SEQ		EQU	TCD_RES   +4    ;ID OF TASK TO BE STARTED ON END OF THIS TASK
TCD_SEQ_TO	EQU	TCD_SEQ   +4    ;ID OF TASK WHOS END WILL START THIS TASK
TCD_SIZE	EQU	TCD_SEQ_TO+4	;SIZE OF TCD IN	BYTES.
)ELSE(
TCD_EAX		EQU	0		;STARTUP PARAMETER 1
TCD_EBX		EQU	TCD_EAX	  +2	;STARTUP PARAMETER 2
TCD_DS		EQU	TCD_EBX	  +2	;STARTUP DS
TCD_ES		EQU	TCD_DS	  +2	;STARTUP ES
TCD_ESP		EQU	TCD_ES	  +2	;STARTUP SP
TCD_SS		EQU	TCD_ESP	  +2	;STARTUP SS
TCD_EIP		EQU	TCD_SS	  +2	;ENTRY POINT OFFSET
TCD_CS		EQU	TCD_EIP	  +2	;ENTRY POINT SEGMENT
TCD_LOAD	EQU	TCD_CS	  +2	;RESERVED
TCD_EFG		EQU	TCD_LOAD	;LOCAL EVENTFLAG GROUP
TCD_TIME	EQU	TCD_LOAD  +4	;OVERRIDE TIME:	UNIT, NUMBER OF	UNITS.
TCD_OVPRI	EQU	TCD_TIME  +2	;OVERRIDE PRIORITY INCREMENT.
TCD_BPRI	EQU	TCD_OVPRI +1	;BOUNDARY ON PRIORITY OVERRIDES.
TCD_INPRI	EQU	TCD_BPRI  +1	;INHERENT PRIORITY
TCD_PID		EQU	TCD_INPRI +1	;RESERVED,HAS TO BE 0 FOR TCB DETECTION
TCD_FLAGS	EQU	TCD_PID	  +1	;TASK FLAG WORD: SEE TCB_FLAGS.
TCD_RR_TICKS	EQU	TCD_FLAGS +2	;TASK SPECIFIC ROUND ROBIN COUNT
					;IF X_RR_BOUND IS 0FFFFH.
TCD_RES		EQU	TCD_RR_TICKS +2	;RESERVED
TCD_SIZE	EQU	TCD_RES	  +2	;SIZE OF TCD IN	BYTES.
)FI

;
;   TCB: TASK (DYNAMIC)	CONTROL	BLOCK.
;
%IF(%RM3)THEN(			
TCB_LINK	EQU	0		;FORWARD LINK OR 0.
TCB_PRI		EQU	TCB_LINK  +4	;PRIORITY.
TCB_STATE	EQU	TCB_PRI	  +1	;CURRENT STATE:	SEE BELOW.
TCB_ESP		EQU	TCB_STATE +1	;CURRENT STACK OFFSET
TCB_SS		EQU	TCB_ESP	  +4	;CURRENT STACK SELECTOR
TCB_SCHDL	EQU	TCB_SS	  +2	;LAST START TIME, ABSOLUTE MSEC.
TCB_QRST	EQU	TCB_SCHDL +8	;RCB QUEUE HEAD.
TCB_CRCB	EQU	TCB_QRST  +4	;CURRENT RCB.
TCB_TMB		EQU	TCB_CRCB  +4	;TMB FOR PRIORITY OVERRIDE OR ENDR.
TCB_PID		EQU	TCB_TMB	  +4	;RESERVED
TCB_FLAGS	EQU	TCB_PID	  +1	;TASK FLAGS: SEE BELOW.
TCB_MSG		EQU	TCB_FLAGS +1	;MESSAGE QUEUE
TCB_STMB	EQU	TCB_MSG	  +4	;OFFSET	ADDRESS	OF TMB (TIMEOUT)
TCB_TCD		EQU	TCB_STMB  +4	;TCD FAR ADDRESS(2 BYTES ARE UNUSED)
TCB_SEL		EQU	TCB_TCD	  +6	;CONTROL OFFSET
TCB_RES		EQU	TCB_SEL	  +2	;RESERVED
TCB_CR_TDP	EQU	TCB_RES   +2	;CRUN TASK DATA POINTER
TCB_CR_INHP	EQU	TCB_CR_TDP  +6	;CRUN INHERITANCE POINTER
TCB_TASKTYPE	EQU	TCB_CR_INHP +6	;TASK TYPE
TCB_LSEG	EQU	TCB_TASKTYPE +2	;LOADER RESULT SEGMENT
TCB_NEXTSMR	EQU	TCB_LSEG     +2	;SMR CHAIN
TCB_SIZE	EQU	TCB_NEXTSMR  +4	;SIZE OF TCB IN	BYTES.
)ELSE(
TCB_LINK	EQU	0		;FORWARD LINK OR 0.
TCB_PRI		EQU	TCB_LINK  +2	;PRIORITY.
TCB_STATE	EQU	TCB_PRI	  +1	;CURRENT STATE:	SEE BELOW.
TCB_ESP		EQU	TCB_STATE +1	;CURRENT STACK OFFSET
TCB_SS		EQU	TCB_ESP	  +2	;CURRENT STACK SELECTOR
TCB_SCHDL	EQU	TCB_SS	  +2	;LAST START TIME, ABSOLUTE MSEC.
TCB_QRST	EQU	TCB_SCHDL +6	;RCB QUEUE HEAD.
TCB_CRCB	EQU	TCB_QRST  +2	;CURRENT RCB.
TCB_TMB		EQU	TCB_CRCB  +2	;TMB FOR PRIORITY OVERRIDE OR ENDR.
TCB_PID		EQU	TCB_TMB	  +2	;RESERVED
TCB_FLAGS	EQU	TCB_PID	  +1	;TASK FLAGS: SEE BELOW.
TCB_MSG		EQU	TCB_FLAGS +1	;MESSAGE QUEUE
TCB_STMB	EQU	TCB_MSG	  +2	;OFFSET	ADDRESS	OF TMB (TIMEOUT)
TCB_TCD		EQU	TCB_STMB  +2	;TCD FAR ADDRESS(2 BYTES ARE UNUSED)
TCB_SEL		EQU	TCB_TCD   +4	;CONTROL OFFSET
TCB_SIZE	EQU	TCB_SEL   +2	;SIZE OF TCB IN	BYTES.
)FI
;
;   TASK FLAG BITS:
;
TFL_NPX		EQU	000000000001B	;TASK USES NPX
TFL_NPX_INIT	EQU	000000000010B	;NPX INITIALIZED
TFL_NOHLT	EQU	000000000100B	;TASK MAY NOT BE HALTED	(A DEBUGGER)
TFL_OVPRI	EQU	000000001000B	;OVERRIDE PRIORITY AFTER TIME EXPIRES
TFL_NEW_IF	EQU	000000010000B	;THE LAST SVC CALL FROM	THE TASK WAS
					;FROM THE NEW INTERFACE
TFL_FLAT_IF	EQU	000000100000B	;THE LAST SVC CALL FROM	THE TASK WAS
					;FROM THE FLAT INTERFACE
TFL_CHILD	EQU	000001000000B	;TASK IS A CHILD OF CREATING TASK
					;CRUN INHERITANCE IS CALLED
TFL_ALLOC	EQU	000010000000B	;TCD/TCB COMBINATION WAS ALLOCATED FROM
		  			;THE SMR (DYNAMICALLY CREATED TASK)
TFL_STK		EQU	000100000000B	;AUTOMATIC STACK SEGMENT ALLOCATION
		    			;LENGTH IN DWORDS IS IN TCD_ESP
TFL_DS		EQU	001000000000B	;AUTOMATIC DATA	SEGMENT	ALLOCATION
		    			;LENGTH IS IN TCD_DS
TFL_FLAG_DELAY	EQU	010000000000B	;PENDING CALL RmSetFlagDelayed
;
;   THE	FOLLOWING SYMBOLS DEFINE THE STATES A TASK MAY OCCUPY:
;
DORMANT		EQU	0		;TASK DORMANT
READY		EQU	1		;     READY
BLOCK		EQU	2		;     BLOCKED (ADDED TO	SUBDESCRIPTOR)
ACTIVE		EQU	3		;     ACTIVE
;
;   SUBDESCRIPTORS ADDED TO "BLOCK" SYMBOL:
;
STA_EF		EQU	4		;EVENT FLAG WAIT
STA_SEMA	EQU	4+ STA_EF	;SEMAPHORE OR CONTROL WAIT
STA_LOAD	EQU	4+ STA_SEMA	;RESERVED
STA_STRT	EQU	4+ STA_LOAD	;WAIT FOR TARGET  TO START
STA_ENDT	EQU	4+ STA_STRT	;WAIT FOR TARGET  TO TERMINATE.
STA_MSG		EQU	4+ STA_ENDT	;WAIT TO RECEIVE MESSAGE
STA_MSGRCVD	EQU	4+ STA_MSG	;WAIT FOR OWN MESSAGE TO BE RECEIVED
STA_POOL	EQU	4+ STA_MSGRCVD	;WAIT FOR ALLOCATABLE MEMORY
STA_HLT		EQU	4+ STA_POOL	;DEBUGGER HALTED .
STA_BREAK	EQU	4+ STA_HLT	;DEBUGGER BREAKPOINTED.
STA_PAUSE	EQU	4+ STA_BREAK	;IN PAUSE CONDITION.
STA_TSKSTCK	EQU	4+ STA_PAUSE	;INVALID TASK STACK SELECTOR
STA_WAIT	EQU	4+ STA_TSKSTCK	;WAITING I/O COMPLETION
STA_ABORT	EQU	4+ STA_WAIT	;RESERVED
STA_SVC		EQU	4+ STA_ABORT	;RESERVED
STA_ENDR	EQU	4+ STA_SVC	;AWAITING TIMED	"RESTART"
STA_ERR0	EQU	4+ STA_ENDR	;RUN TIME ERROR, EXCEPTION  0.
STA_ERR1	EQU	4+ STA_ERR0	; "   "	    "	 EXCEPTION  1.
STA_ERR2	EQU	4+ STA_ERR1	; "   "	    "	 EXCEPTION  3.
STA_ERR3	EQU	4+ STA_ERR2	; "   "	    "	 EXCEPTION  4.
STA_ERR4	EQU	4+ STA_ERR3	; "   "	    "	 EXCEPTION  5.
STA_ERR5	EQU	4+ STA_ERR4	; "   "	    "	 EXCEPTION  6.
STA_ERR6	EQU	4+ STA_ERR5	; "   "	    "	 EXCEPTION  7.
STA_ERR7	EQU	4+ STA_ERR6	; "   "	    "	 EXCEPTION  8.
STA_ERR8	EQU	4+ STA_ERR7	; "   "	    "	 EXCEPTION  9.
STA_ERR9	EQU	4+ STA_ERR8	; "   "	    "	 EXCEPTION 13.
STA_ERR10	EQU	4+ STA_ERR9	; "   "	    "	 EXCEPTION 16.
STA_ERR11	EQU	4+ STA_ERR10    ; "   "	    "    EXCEPTION 10.
STA_ERR12	EQU	4+ STA_ERR11    ; "   "	    "    EXCEPTION 11.
STA_ERR13	EQU	4+ STA_ERR12    ; "   "	    "    EXCEPTION 12.
STA_ERR14	EQU	4+ STA_ERR13    ; "   "	    "    EXCEPTION 14.
STA_ERR15	EQU	4+ STA_ERR14    ; "   "	    "    EXCEPTION 17.
STA_ERR16	EQU	4+ STA_ERR15    ; "   "	    "    EXCEPTION 17.
LAST_ERR	EQU	STA_ERR15
RES_ERR		EQU	STA_ERR0+(31 SHL 2) ; RESERVE SOME RUN TIME ERRORS
STA_LOOK	EQU	RES_ERR+4	;WAIT FOR STRING TO	BE CATALOGED
STA_KEND	EQU	STA_LOOK+4	;TASK KILLED WITH END OPTION
STA_KDEL	EQU	STA_KEND+4	;TASK KILLED WITH DELETE OPTION

; ------------------------
; GENERAL STRUCTURE OF TSS
; ------------------------
%IF(%RM3)THEN(
TSS_STRUC	STRUC
	LINK	DW ?
	LINK@	DW ?
	ESP0	DD ?
	SS0	DW ?
	SS0@	DW ?
	ESP1	DD ?
	SS1	DW ?
	SS1@	DW ?
	ESP2	DD ?
	SS2	DW ?
	SS2@	DW ?
	CR3_	DD ?
	EIP_	DD ?
	EFLAGS_	DD ?
	EAX_	DD ?
	ECX_	DD ?
	EDX_	DD ?
	EBX_	DD ?
	ESP_	DD ?
	EBP_	DD ?
	ESI_	DD ?
	EDI_	DD ?
	ES_	DW ?
	ES@	DW ?
	CS_	DW ?
	CS@	DW ?
	SS_	DW ?
	SS@	DW ?
	DS_	DW ?
	DS@	DW ?
	FS_	DW ?
	FS@	DW ?
	GS_	DW ?
	GS@	DW ?
	LDT_	DW ?
	LDT@	DW ?
	TRAP	DW ?
	IO_MAP	DW ?
TSS_STRUC	ENDS
)FI

;
;   DCD: DEVICE	CONTROL	DEFINITION BLOCK.
;
%IF(%RM3)THEN(			
DCD_UCD		EQU	0		;RESERVED.
DCD_UNITS	EQU	DCD_UCD	  +4	;RESERVED.
DCD_SHR		EQU	DCD_UNITS +1	;DEVICE	NR. OF SHARING DEVICE
		    			;(0FFH = NONE).
DCD_INIT	EQU	DCD_SHR	  +1	;ADDRESS OF INITIALIZATION ROUTINE.
DCD_SVC		EQU	DCD_INIT  +4	;ADDRESS OF IRB	INPUT ROUTINE
		   			;(SOMETIMES CALLED SVC REQUEST HANDLER)
DCD_FLAGS	EQU	DCD_SVC	  +4	;FLAGS:	SEE BELOW.
DCD_FMAX	EQU	DCD_FLAGS +1	;MAXIMUM FUNCTION CODE FOR DRIVER.
DCD_RES		EQU	DCD_FMAX  +1	;RESERVED SPACE.
DCD_SIZE	EQU	DCD_RES	  +4	;SIZE OF DCD IN	BYTES.
)ELSE(
DCD_UCD		EQU	0		;RESERVED.
DCD_UNITS	EQU	DCD_UCD	  +2	;RESERVED.
DCD_SHR		EQU	DCD_UNITS +1	;DEVICE	NR. OF SHARING DEVICE
		    			;(0FFH = NONE).
DCD_INIT	EQU	DCD_SHR	  +1	;ADDRESS OF INITIALIZATION ROUTINE.
DCD_SVC		EQU	DCD_INIT  +4	;ADDRESS OF IRB	INPUT ROUTINE
		   			;(SOMETIMES CALLED SVC REQUEST HANDLER)
DCD_FLAGS	EQU	DCD_SVC	  +4	;FLAGS:	SEE BELOW.
DCD_FMAX	EQU	DCD_FLAGS +1	;MAXIMUM FUNCTION CODE FOR DRIVER.
DCD_RES		EQU	DCD_FMAX  +1	;RESERVED SPACE.
DCD_SIZE	EQU	DCD_RES	  +2	;SIZE OF DCD IN	BYTES.
)FI
;
;   FLAGS FOR DCD_FLAGS	FIELD OF DCD:
;
DFL_PARA	EQU	00000001B	;PARALLEL DRIVER.
DFL_TYPE2	EQU	00000010B	;TYPE 2 DRIVER.
DFL_DORMANT	EQU	00000100B	;DRIVER DORMANT.
;
;   UCD: UNIT CONTROL DEFINITION BLOCK.
;
%IF(%RM3)THEN(			
UCD_PID		EQU	0		;RESERVED
UCD_INTNO	EQU	UCD_PID   +1	;INTERRUPT NUMBER.
UCD_INTADR	EQU	UCD_INTNO +1	;INTERRUPT VECTOR ADDRESS.
UCD_UNS		EQU	UCD_INTADR+6	;UNSOLICITED INTERRUPT TASK NUMBER.
UCD_PORT 	EQU	UCD_UNS	  +2	;UNIT-DEPENDENT	PARAMETERS:
		    			;246 BYTES ROOM ALLOWED.
UCD_SIZE	EQU	256		;SIZE OF UCD IN	BYTES.
)ELSE(
UCD_PID		EQU	0		;RESERVED
UCD_INTNO	EQU	UCD_PID   +1	;INTERRUPT NUMBER.
UCD_INTADR	EQU	UCD_INTNO +1	;INTERRUPT VECTOR ADDRESS.
UCD_UNS		EQU	UCD_INTADR+4	;UNSOLICITED INTERRUPT TASK NUMBER.
UCD_PORT 	EQU	UCD_UNS	  +2	;UNIT-DEPENDENT	PARAMETERS:
		    			;246 BYTES ROOM ALLOWED.
UCD_SIZE	EQU	128		;SIZE OF UCD IN	BYTES.
)FI

RIOBYTE		EQU	40H		;RIO BYTE UNIT TYPE
RIOBLOCK	EQU	80H		;RIO BLOCK UNIT TYPE
;
;   DCB: DEVICE	CONTROL	(DYNAMIC) BLOCK
;
%IF(%RM3)THEN(			
DCB_LINK	EQU	0		;FORWARD LINK OR 0.
DCB_ID		EQU	DCB_LINK  +4	;DEVICE	NUMBER.
DCB_STS		EQU	DCB_ID	  +1	;DRIVER	STATUS BYTE.
DCB_QIRB	EQU	DCB_STS	  +1	;DRIVER	IRB QUEUE.
DCB_CIRB	EQU	DCB_QIRB  +4	;DRIVER	CURRENT	IRB.
DCB_UCB		EQU	DCB_CIRB  +4	;ADDRESS OF UNIT 0 UCB
DCB_DCD		EQU	DCB_UCB	  +4	;OFFSET	OF DCD.
DCB_GPR		EQU	DCB_DCD	  +4	;DRIVER	GENERAL	STORAGE.
DCB_SIZE	EQU	256		;SIZE OF DCB IN	BYTES.
)ELSE(
DCB_LINK	EQU	0		;FORWARD LINK OR 0.
DCB_ID		EQU	DCB_LINK  +2	;DEVICE	NUMBER.
DCB_STS		EQU	DCB_ID	  +1	;DRIVER	STATUS BYTE.
DCB_QIRB	EQU	DCB_STS	  +1	;DRIVER	IRB QUEUE.
DCB_CIRB	EQU	DCB_QIRB  +2	;DRIVER	CURRENT	IRB.
DCB_UCB		EQU	DCB_CIRB  +2	;ADDRESS OF UNIT 0 UCB
DCB_DCD		EQU	DCB_UCB	  +2	;OFFSET	OF DCD.
DCB_GPR		EQU	DCB_DCD	  +2	;DRIVER	GENERAL	STORAGE.
DCB_SIZE	EQU	128		;SIZE OF DCB IN	BYTES.
)FI
;
;   UCB: UNIT CONTROL (DYNAMIC)	BLOCK
;
%IF(%RM3)THEN(			
UCB_LINK	EQU	0		;FORWARD LINK OR 0.
UCB_UNIT	EQU	UCB_LINK  +4	;UNIT NUMBER
UCB_STS		EQU	UCB_UNIT  +1	;UNIT STATUS BYTE.
UCB_QIRB	EQU	UCB_STS	  +1	;UNIT IRB QUEUE.
UCB_CIRB	EQU	UCB_QIRB  +4	;UNIT CURRENT IRB.
UCB_SEG		EQU	UCB_CIRB  +4	;SEGMENT OF UCD.
UCB_DCB		EQU	UCB_SEG	  +2	;ADDRESS OF DRIVER DCB.
UCB_UCD		EQU	UCB_DCB	  +4	;OFFSET	OF UCD.
UCB_TCB		EQU	UCB_UCD	  +4	;RESERVER'S TCB	ADDRESS	OR 0.
UCB_GPR		EQU	UCB_TCB	  +4	;GENERAL UNIT STORAGE.
UCB_SIZE	EQU	256		;SIZE OF UCB IN BYTES.
)ELSE(
UCB_LINK	EQU	0		;FORWARD LINK OR 0.
UCB_UNIT	EQU	UCB_LINK  +2	;UNIT NUMBER
UCB_STS		EQU	UCB_UNIT  +1	;UNIT STATUS BYTE.
UCB_QIRB	EQU	UCB_STS   +1	;UNIT IRB QUEUE.
UCB_CIRB	EQU	UCB_QIRB  +2	;UNIT CURRENT IRB.
UCB_SEG		EQU	UCB_CIRB  +2	;RESERVED
UCB_DCB		EQU	UCB_SEG   +2	;ADDRESS OF DRIVER DCB.
UCB_UCD		EQU	UCB_DCB   +2	;OFFSET IN MTOS_GROM OF UCD.
UCB_TCB		EQU	UCB_UCD   +2	;RESERVER'S TCB ADDRESS OR 0.
UCB_GPR		EQU	UCB_TCB   +2	;GENERAL UNIT STORAGE.
UCB_SIZE	EQU	128        	;SIZE OF UCB IN BYTES.
)FI
;
;   MPD:    MEMORY POOL	DEFINITION BLOCK.
;
%IF(%RM3)THEN(			
MPD_OFF		EQU	0		;RESERVED.
MPD_DS		EQU	MPD_OFF	+4	;SELECTOR OF POOL (MUST BE UNIQUE)
MPD_SZE		EQU	MPD_DS	+2	;SIZE OF POOL (MUST	BE >= 4)
MPD_SIZE	EQU	MPD_SZE	+4	;SIZE OF MPD IN BYTES.
)ELSE(
MPD_OFF		EQU	0		;RESERVED.
MPD_DS		EQU	MPD_OFF	+2	;SELECTOR OF POOL (MUST BE UNIQUE)
MPD_SZE		EQU	MPD_DS	+2	;SIZE OF POOL (MUST	BE >= 4)
MPD_SIZE	EQU	MPD_SZE	+4	;SIZE OF MPD IN BYTES.
)FI
;
;   DDD:    DISCRETE DATA DEFINITION.
;
%IF(%RM3)THEN(			
DDD_OFF		EQU	0		;OFFSET	OF DISCRETE
DDD_SEG		EQU	DDD_OFF	+4	;SELECTOR OF DISCRETE
DDD_SIZE	EQU	DDD_SEG	+2	;SIZE OF DDD IN BYTES.
)ELSE(
DDD_OFF		EQU	0		;OFFSET	OF DISCRETE
DDD_SEG		EQU	DDD_OFF	+2	;SELECTOR OF DISCRETE
DDD_SIZE	EQU	DDD_SEG	+2	;SIZE OF DDD IN BYTES.
)FI
;
;   EFG:    EVENT FLAG GROUP.
;
%IF(%RM3)THEN(			
EFG_FLAGS	EQU	0		;ACTUAL	GROUP OF FLAGS.
EFG_WAIT	EQU	EFG_FLAGS +4	;LIST OF WAIT BLOCKS (IF -1 NOT	IN LIST).
EFG_SIZE	EQU	EFG_WAIT  +4	;SIZE OF EFG IN	BYTES.
)ELSE(
EFG_FLAGS	EQU	0		;ACTUAL	GROUP OF FLAGS.
EFG_WAIT	EQU	EFG_FLAGS +2	;LIST OF WAIT BLOCKS (IF -1 NOT	IN LIST).
EFG_SIZE	EQU	EFG_WAIT  +2	;SIZE OF EFG IN	BYTES.
)FI
;
;   SEM:    SEMAPHORE CONTROL BLOCK.
;
%IF(%RM3)THEN(			
SEM_TCB		EQU	0		;TCB ADDRESS OF CURRENT OWNER.
SEM_OPRI	EQU	SEM_TCB	 +4	;OWNER PRIORITY AT INVOKATION TIME.
SEM_NPRI	EQU	SEM_OPRI +1	;NEW PRI. CAUSE OF AUTOMATIC INCREASE.
SEM_WAIT	EQU	SEM_NPRI +1	;LIST OF SWBS (IF -1 NOT IN	LIST).
SEM_SIZE	EQU	SEM_WAIT +4	;SIZE OF SEMAPHORE IN BYTES.
)ELSE(
SEM_TCB		EQU	0		;TCB ADDRESS OF CURRENT OWNER.
SEM_OPRI	EQU	SEM_TCB	 +2	;OWNER PRIORITY AT INVOKATION TIME.
SEM_NPRI	EQU	SEM_OPRI +1	;NEW PRI. CAUSE OF AUTOMATIC INCREASE.
SEM_WAIT	EQU	SEM_NPRI +1	;LIST OF SWBS (IF -1 NOT IN	LIST).
SEM_SIZE	EQU	SEM_WAIT +2	;SIZE OF SEMAPHORE IN BYTES.
)FI
;
;   MPB:    MEMORY POOL	(DYNAMIC) BLOCK.
;
%IF(%RM3)THEN(			
MPB_FREEQ	EQU	0		;ABS ADR TO LIST OF FREE BLOCKS
MPB_WAITQ	EQU	MPB_FREEQ+4	;LIST OF PWBS (IF -1 NOT IN LIST).
MPB_STS		EQU	MPB_WAITQ+4	;MARKER
MPB_AVAIL	EQU	MPB_STS	 +4	;NUMBER OF FREE BYTES CURRENTLY
MPB_PCOQ	EQU	MPB_AVAIL+4	;QUEUE OF PHYS. ADR. OF USED BLOCKS
MPB_RES		EQU	MPB_PCOQ +4	;RESERVED
MPB_SEL		EQU	MPB_RES	 +4	;USED SELECTOR (WHOLE POOL IN ONE)
MPB_OWN		EQU	MPB_SEL	 +2	;OWNER CODE (WHOLE POOL IN ONE)
MPB_START	EQU	MPB_OWN	 +2	;ABS START ADR OF POOL
MPB_SZE		EQU	MPB_START+4	;TOTAL POOL SIZE IN BYTES.
MPB_SIZE	EQU	MPB_SZE	 +4	;SIZE OF MPB IN BYTES.
)ELSE(
MPB_FREEQ	EQU	0		;ABS ADR TO LIST OF FREE BLOCKS
MPB_WAITQ	EQU	MPB_FREEQ+4	;LIST OF PWBS (IF -1 NOT IN LIST).
MPB_STS		EQU	MPB_WAITQ+2	;MARKER
MPB_AVAIL	EQU	MPB_STS	 +2	;NUMBER OF FREE BYTES CURRENTLY
MPB_PCOQ	EQU	MPB_AVAIL+4	;QUEUE OF PHYS. ADR. OF USED BLOCKS
MPB_RES		EQU	MPB_PCOQ +4	;RESERVED
MPB_SEL		EQU	MPB_RES	 +4	;USED SELECTOR (WHOLE POOL IN ONE)
MPB_OWN		EQU	MPB_SEL	 +2	;OWNER CODE (WHOLE POOL IN ONE)
MPB_START	EQU	MPB_OWN	 +2	;ABS START ADR OF POOL
MPB_SZE		EQU	MPB_START+4	;TOTAL POOL SIZE IN BYTES.
MPB_SIZE	EQU	MPB_SZE	 +4	;SIZE OF MPB IN BYTES.
)FI
;
;   PCB:    POOL CONTROL BLOCK OF EACH FREE BLOCK INSIDE POOL
;
%IF(%RM3)THEN(			
PCB_		STRUC
PCB_LINK	DD ?			;ABS ADR TO	NEXT FREE BLOCK	OR -1
PCB_LEN		DD ?			;LENGTH OF FREE BLOCK
PCB_		ENDS
PCB_SIZE	EQU SIZE PCB_ 		;SIZE OF CONTROL BLOCK IN BYTES
)ELSE(
PCB_		STRUC
PCB_LINK	DD ?			;ABS ADR TO	NEXT FREE BLOCK	OR -1
PCB_LEN		DD ?			;LENGTH OF FREE BLOCK
PCB_		ENDS
PCB_SIZE	EQU SIZE PCB_ 		;SIZE OF CONTROL BLOCK IN BYTES
)FI

MIN_BLK_SIZE	EQU PCB_SIZE		;MINIMAL REMAINING BLOCK SIZE
;
;   PCO:    OCCUPY CONTROL BLOCK JUST BEFORE EACH USED BLOCK
;
%IF(%RM3)THEN(			
PCO_	STRUC
PCO_FLINK	DD ?			;FORWARD LINK PHYSICAL ADDRESS OR 0
PCO_BLINK	DD ?			;BACKWARD LINK PHYSICAL ADDRESS OR 0
PCO_REQ		DD ?			;REQESTED LENGTH
PCO_SEL		DW ?			;USED SELECTOR
PCO_OWN		DW ?			;OWNER TASK ID, 
					;CODE FOR NO OWNER OR DEVICE DRIVER
PCO_	ENDS
)ELSE(
PCO_	STRUC
PCO_FLINK	DD ?			;FORWARD LINK PHYSICAL ADDRESS OR 0
PCO_BLINK	DD ?			;BACKWARD LINK PHYSICAL ADDRESS OR 0
PCO_REQ		DD ?			;REQESTED LENGTH
PCO_SEL		DW ?			;USED SELECTOR
PCO_OWN		DW ?			;OWNER TASK ID, 
					;CODE FOR NO OWNER OR DEVICE DRIVER
PCO_	ENDS
)FI

PCO_SIZE 	EQU	(SIZE PCO_ + 0FH) AND (NOT 0FH)	;LENGTH	IN BYTES
					;(MULTIPLE OF 16)
CPL_BLOCK	EQU	-1		;INDICATOR FOR COMPLETE	POOL
BO_DEV		EQU	-1		;BLOCK OWNER CODE DEVICE DRIVER
BO_TASK_STACK	EQU	-2		;BLOCK OWNER CODE TASK STACK
BO_TASK_DS	EQU	-3		;BLOCK OWNER CODE TASK DS
BO_NONE		EQU	-4		;BLOCK OWNER CODE NO OWNER
;
;   MBX:    MAILBOX CONTROL BLOCK.
;
%IF(%RM3)THEN(			
MBX_WAITH	EQU	0		;HEAD OF RMB LIST (IF -1 NOT IN	LIST).
MBX_MSGSH	EQU	MBX_WAITH +4	;HEAD OF MMB LIST.
MBX_BOUND	EQU	MBX_MSGSH +4	;MAXIMAL WAITING MESSAGES OR 0.
MBX_WTCNT	EQU	MBX_BOUND +2	;ACTUALY WAITING MESSAGES.
MBX_SIZE	EQU	MBX_WTCNT +2	;SIZE OF MAILBOX IN BYTES.
)ELSE(
MBX_WAITH	EQU	0		;HEAD OF RMB LIST (IF -1 NOT IN	LIST).
MBX_MSGSH	EQU	MBX_WAITH +2	;HEAD OF MMB LIST.
MBX_BOUND	EQU	MBX_MSGSH +2	;MAXIMAL WAITING MESSAGES OR 0.
MBX_WTCNT	EQU	MBX_BOUND +2	;ACTUALY WAITING MESSAGES.
MBX_SIZE	EQU	MBX_WTCNT +2	;SIZE OF MAILBOX IN BYTES.
)FI
;
;   THE	FOLLOWING DATA STRUCTURES
;   TO BE DESCRIBED SHORTLY ARE	ALL BUILT IN BLOCKS OF GLOBAL RAM WHICH
;   ARE	ALLOCATED AS NEEDED FROM THE SYSTEM MEMORY RESOURCE (SMR).
;   ALL	SMR BLOCKS ARE ALL EQUAL IN SIZE REGARDLESS OF APPLICATION. THE
;   "LENGTHS" GIVEN FOR	THE ABOVEMENTIONED DATA	STRUCTURES ONLY	SPECI-
;   FY HOW MUCH	OF THE BLOCK THEY USE.
;
;   AVAILABILITY OF SUFFICIENT SMR BLOCKS TO COPE WITH WORST-CASE SYSTEM
;   CONDITIONS IS A GATING CONDITION FOR THE DISPATCHING OF REQUESTS FOR
;   SERVICE.
;
;   SIZE OF SMR	BLOCK:
;
SMR_LINK	EQU	TCB_NEXTSMR	;LINK TO NEXT SMR
					;ALL SMRS ARE LINKED TOGETHER
					;INDEPENDEND OF THEIR CONTENTS
SMR_SIZE	EQU	TCB_SIZE	;SIZE IN BYTES.
					;RCB_SIZE IS SMR_SIZE-4
;
;   EWB:    EVENT FLAG WAIT BLOCK.
;
%IF(%RM3)THEN(			
EWB_LINK	EQU	0		;FORWARD LINK OR 0.
EWB_PRI		EQU	EWB_LINK +4	;WAIT BLOCK PRIORITY.
EWB_TYPE	EQU	EWB_PRI	 +1	;TEST TYPE: 0= AND, 1= OR.
EWB_MASK	EQU	EWB_TYPE +1	;TEST MASK
EWB_TCB		EQU	EWB_MASK +4	;TCB ADDRESS OF REQUESTOR.
EWB_ADDR	EQU	EWB_TCB	 +4	;POINTER TO USER BUFFER.
EWB_SIZE	EQU	EWB_ADDR +6	;SIZE OF EWB IN BYTES.
)ELSE(
EWB_LINK	EQU	0		;FORWARD LINK OR 0.
EWB_PRI		EQU	EWB_LINK +2	;WAIT BLOCK PRIORITY.
EWB_TYPE	EQU	EWB_PRI	 +1	;TEST TYPE: 0= AND, 1= OR.
EWB_MASK	EQU	EWB_TYPE +1	;TEST MASK
EWB_TCB		EQU	EWB_MASK +2	;TCB ADDRESS OF REQUESTOR.
EWB_ADDR	EQU	EWB_TCB	 +2	;POINTER TO USER BUFFER.
EWB_SIZE	EQU	EWB_ADDR +4	;SIZE OF EWB IN BYTES.
)FI
;
;   MMB:    MAILED MESSAGE BLOCK.
;
%IF(%RM3)THEN(			
MMB_LINK	EQU	0		;FORWARD LINK OR 0.
MMB_PRI		EQU	MMB_LINK +4	;PRIORITY.
MMB_COOR	EQU	MMB_PRI	 +1	;COORDINATION: 
			   		;00=	NONE,01= OVFL SET
		   			;10= WAIT TILL ACCEPTED
		    			;11= WAIT AND OVFL.
MMB_P1		EQU	MMB_COOR +1	;WORD 1
MMB_P2		EQU	MMB_P1	 +4	;WORD 2
MMB_P3		EQU	MMB_P2	 +4	;WORD 3 OF MESSAGE.
MMB_TCB		EQU	MMB_P3	 +4	;TCB OF SENDER.
MMB_TIM_RECV	EQU 	MMB_TCB  +4	;ACKNOLEDGE ROUTINE ON RECEPTION OR 0
MMB_TIB		EQU	MMB_TIM_RECV +4	;CORRESPONDING TIB OR 0
MMB_SIZE 	EQU	MMB_TIB	 +4	;SIZE OF MMB IN BYTES.
)ELSE(
MMB_LINK	EQU	0		;FORWARD LINK OR 0.
MMB_PRI		EQU	MMB_LINK +2	;PRIORITY.
MMB_COOR	EQU	MMB_PRI	 +1	;COORDINATION: 
			   		;00=	NONE,01= OVFL SET
		   			;10= WAIT TILL ACCEPTED
		    			;11= WAIT AND OVFL.
MMB_P1		EQU	MMB_COOR +1	;WORD 1
MMB_P2		EQU	MMB_P1	 +2	;WORD 2
MMB_P3		EQU	MMB_P2	 +2	;WORD 3 OF MESSAGE.
MMB_TCB		EQU	MMB_P3	 +2	;TCB OF SENDER.
MMB_TIM_RECV	EQU 	MMB_TCB  +2	;ACKNOLEDGE ROUTINE ON RECEPTION OR 0
MMB_TIB		EQU	MMB_TIM_RECV +2	;CORRESPONDING TIB OR 0
MMB_P4		EQU	MMB_TIB+2	;WORD 3 OF MESSAGE.
MMB_P5		EQU	MMB_P4+2	;WORD 3 OF MESSAGE.
MMB_SIZE	EQU	MMB_P5+2	;SIZE OF MMB IN BYTES.
)FI
;
;   RMB:    RECEIVE-MESSAGE BLOCK.
;
%IF(%RM3)THEN(			
RMB_LINK	EQU	0		;FORWARD LINK OR 0.
RMB_PRI		EQU	RMB_LINK +4	;PRIORITY(ONE BYTE RESERVED).
RMB_TCB		EQU	RMB_PRI  +2	;TCB OF REQUESTOR.
RMB_RADR	EQU	RMB_TCB	 +4	;FAR ADDRESS OF 6 BYTE BUFFER.
RMB_MADR	EQU	RMB_RADR +6	;FAR ADDRESS OF 6 BYTE BUFFER.
RMB_SIZE	EQU	RMB_RADR +6	;SIZE OF RMB IN BYTES.
)ELSE(
RMB_LINK	EQU	0		;FORWARD LINK OR 0.
RMB_PRI		EQU	RMB_LINK +2	;PRIORITY(ONE BYTE RESERVED).
RMB_TCB		EQU	RMB_PRI  +2	;TCB OF REQUESTOR.
RMB_RADR	EQU	RMB_TCB	 +2	;FAR ADDRESS OF 6 BYTE BUFFER.
RMB_MADR	EQU	RMB_RADR +4	;FAR ADDRESS OF 6 BYTE BUFFER.
RMB_SIZE	EQU	RMB_RADR +4	;SIZE OF RMB IN BYTES.
)FI
;
;   SWB:    SEMAPHORE (OR CONTROLLED PROGRAM) WAIT BLOCK.
;
%IF(%RM3)THEN(			
SWB_LINK	EQU	0		;FORWARD LINK OR 0.
SWB_PRI		EQU	SWB_LINK +4	;PRIORITY(ONE BYTE RESERVED).
SWB_TCB		EQU	SWB_PRI	 +2	;TCB ADDRESS OF REQUESTOR.
SWB_SIZE	EQU	SWB_TCB	 +4	;SIZE OF SWB IN BYTES.
)ELSE(
SWB_LINK	EQU	0		;FORWARD LINK OR 0.
SWB_PRI		EQU	SWB_LINK +2	;PRIORITY(ONE BYTE RESERVED).
SWB_TCB		EQU	SWB_PRI	 +2	;TCB ADDRESS OF REQUESTOR.
SWB_SIZE	EQU	SWB_TCB	 +2	;SIZE OF SWB IN BYTES.
)FI
;
;   PWB:    POOL WAIT BLOCKS.
;
%IF(%RM3)THEN(			
PWB_LINK	EQU	0		;FORWARD LINK OR 0.
PWB_PRI		EQU	PWB_LINK +4	;PRIORITY.
PWB_TCB		EQU	PWB_PRI	 +4	;TCB ADDRESS OF REQUESTOR.
PWB_OWN		EQU	PWB_TCB	 +4	;OWNER TCB,	CODE FOR NO OWNER OR DEV.
PWB_LEN		EQU	PWB_OWN	 +4	;BLOCK SIZE	NEEDED.
PWB_BUFR	EQU	PWB_LEN	 +4	;FAR ADDR. OF POOL-BLOCK-ADDRESS BUFFER
PWB_MODE	EQU	PWB_BUFR +6	;INDICATOR FOR FLAT
PWB_RBUFR	EQU	PWB_MODE +2	;FAR ADDR. OF REALLOC POOL-BLOCK-ADDRESS BUFFER
PWB_SIZE	EQU	PWB_RBUFR+6	;SIZE OF PWB IN BYTES.
)ELSE(
PWB_LINK	EQU	0		;FORWARD LINK OR 0.
PWB_PRI		EQU	PWB_LINK +2	;PRIORITY.
PWB_TCB		EQU	PWB_PRI	 +1	;TCB ADDRESS OF REQUESTOR.
PWB_OWN		EQU	PWB_TCB	 +2	;OWNER TCB,	CODE FOR NO OWNER OR DEV.
PWB_LEN		EQU	PWB_OWN	 +2	;BLOCK SIZE	NEEDED.
PWB_BUFR	EQU	PWB_LEN	 +4	;FAR ADDR. OF POOL-BLOCK-ADDRESS BUFFER
PWB_MODE	EQU	PWB_BUFR +4	;INDICATOR FOR FLAT
PWB_RBUFR	EQU	PWB_MODE +2	;FAR ADDR. OF REALLOC POOL-BLOCK-ADDRESS BUFFER
PWB_SIZE	EQU	PWB_RBUFR+4	;SIZE OF PWB IN BYTES.
)FI
;
;   IRB:    I/O	REQUEST	BLOCK.
;
%IF(%RM3)THEN(			
IRB_LINK	EQU	0		;FORWARD LINK OR 0.
IRB_PRI		EQU	IRB_LINK  +4	;PRIORITY.
IRB_TCB		EQU	IRB_PRI	  +2	;TCB ADDRESS OF	REQUESTOR.
IRB_UCB		EQU	IRB_TCB	  +4	;UCB OF	REQUESTED UNIT.
IRB_TMB		EQU	IRB_UCB	  +4	;ADDRESS OF TMB	FOR THIS REQUEST
IRB_RIO		EQU	IRB_TMB	  +4	;START OF SDB IMAGE:
IRB_FUNCT	EQU	IRB_RIO	  +1	;   FUNCTION CODE,
IRB_DEVICE	EQU	IRB_FUNCT +1	;   DEVICE NUMBER,
IRB_UNIT	EQU	IRB_DEVICE+1	;   UNIT   NUMBER,
IRB_GRP		EQU	IRB_UNIT  +1	;   FLAG GROUP (ALWAYS 0),
IRB_FLAGS	EQU	IRB_GRP	  +1	;   FLAG MASK,
IRB_STATUS	EQU	IRB_FLAGS +4	;   ADDRESS OF STATUS BUFFER,
IRB_BUFR	EQU	IRB_STATUS+6	;   ADDRESS OF DEVICE-DEPENDENT
		    			;	PARAMETER LIST.
IRB_SEQ		EQU	IRB_BUFR  +6	;RESERVED
IRB_SIZE	EQU	IRB_SEQ	  +2	;SIZE OF IRB IN	BYTES.
)ELSE(
IRB_LINK	EQU	0		;FORWARD LINK OR 0.
IRB_PRI		EQU	IRB_LINK  +2	;PRIORITY.
IRB_TCB		EQU	IRB_PRI	  +2	;TCB ADDRESS OF	REQUESTOR.
IRB_UCB		EQU	IRB_TCB	  +2	;UCB OF	REQUESTED UNIT.
IRB_TMB		EQU	IRB_UCB	  +2	;ADDRESS OF TMB	FOR THIS REQUEST
IRB_RIO		EQU	IRB_TMB	  +2	;START OF SDB IMAGE:
IRB_FUNCT	EQU	IRB_RIO	  +1	;   FUNCTION CODE,
IRB_DEVICE	EQU	IRB_FUNCT +1	;   DEVICE NUMBER,
IRB_UNIT	EQU	IRB_DEVICE+1	;   UNIT   NUMBER,
IRB_GRP		EQU	IRB_UNIT  +1	;   FLAG GROUP (ALWAYS 0),
IRB_FLAGS	EQU	IRB_GRP	  +1	;   FLAG MASK,
IRB_STATUS	EQU	IRB_FLAGS +2	;   ADDRESS OF STATUS BUFFER,
IRB_BUFR	EQU	IRB_STATUS+4	;   ADDRESS OF DEVICE-DEPENDENT
		    			;	PARAMETER LIST.
IRB_SEQ		EQU	IRB_BUFR  +4	;RESERVED
IRB_SIZE	EQU	IRB_SEQ	  +2	;SIZE OF IRB IN	BYTES.
)FI
;
;   TMB:    TIME MONITOR BLOCK.
;
%IF(%RM3)THEN(			
;   COMMON PART
;
TMB_LINK	EQU	0		;FORWARD LINK OR 0.
TMB_LTIME	EQU	TMB_LINK +4	;LOW  DWORD, ABSOLUTE EXPIRATION TIME.
TMB_HTIME	EQU	TMB_LTIME+4	;HIGH DWORD, ABSOLUTE EXPIRATION TIME.
TMB_TYPE	EQU	TMB_HTIME+4	;TMB TYPE:
			   		;TYPE 1= DRIVER OR TOD TIMEOUT.
					;TYPE 2= TASK PAUSE	EXPIRATION.
					;TYPE 3= EVENT FLAG	TO BE SET.
					;TYPE 4= TASK RESTART TIMER.
					;TYPE 5= OVERRIDE-PRIORITY TIMER.
					;TYPE 6= RESERVED
					;TYPE 7= RESERVED
					;TYPE 8= SVC TIMEOUT.
					;TYPE 9= DELAYED MESSAGES.
;
;   TYPE 1
;
TMB_UCB		EQU	TMB_TYPE  +2	;UCB OF	UNIT
TMB_SADR	EQU	TMB_UCB	  +4	;ADDRESS OF TIMEOUT ROUTINE
;
;   TYPE 2
;
TMB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
;
;   TYPE 3
;
TMB_EFGRP	EQU	TMB_TYPE  +1	;EVENT FLAG GROUP
;MB_TCB		EQU	TMB_EFGRP +1	;TCB OF	REQUESTOR
TMB_EFMSK	EQU	TMB_TCB	  +4	;EVENT FLAG MASK
;
;   TYPE 4
;
;MB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
;
;   TYPE 5
;
;MB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
TMB_OVPRI	EQU	TMB_TCB	  +4	;PRIORITY-OVERRIDE INCREMENT
TMB_BPRI	EQU	TMB_OVPRI +1	;OVERRIDE-PRIORITY BOUNDARY
TMB_OVTIME	EQU	TMB_BPRI  +1	;OVERRIDE TIME INTERVAL, MSEC.
;
;   TYPE 6
;
;   TYPE 7
;
;   NUMBER OF SVCS WITH	TIMEOUT:
;
TIMEOUT_SVC_NUM	EQU 6	    		;EQUAL NUMBER OF BITS DEFINED ABOVE.
;
;   TYPE 8
;
TMB_TJT		EQU	TMB_TYPE  +2	;TIMEOUT JUMP TABLE
TMB_CSVC	EQU	TMB_TJT	  +4	;BIT CODED SVC WITH ACTIVE TIMEOUT
TMB_QH		EQU	TMB_CSVC  +2	;SPECIFIC QUEUE	HEADER
TMB_WB		EQU	TMB_QH	  +4	;SPECIFIC WAIT BLOCK
TMB_SSVC	EQU	TMB_WB	  +4	;TIMEOUT BITS DEFINED ABOVE.
TMB_NSVC	EQU	TMB_SSVC  +2	;SVC NUMBER BEFORE TIMEOUT.
TMB_STIME	EQU	TMB_NSVC  +2	;SVC SPECIFIC TIMEOUT VALUES.
TMB_SIZE	EQU	TMB_STIME +TIMEOUT_SVC_NUM*2 ;SIZE OF TMB IN BYTES.
;
;   TYPE 9
;
TMB_ALARM	EQU	TMB_TYPE  +4	;ALARM ROUTINE,	CALLED ON EXPIRATION
TMB_TIB		EQU	TMB_ALARM +4	;CORRESPONDING TIB
)ELSE(
TMB_LINK	EQU	0		;FORWARD LINK OR 0.
TMB_TIME	EQU	TMB_LINK+2	;WORD-WORD MILLISECOND COUNTDOWN.
TMB_MTIME	EQU	TMB_TIME	;MIDDLE WORD, ABSOLUTE EXPIRATION TIME
TMB_LTIME	EQU	TMB_TIME+2	;LOW WORD, ABSOLUTE EXPIRATION TIME.
TMB_TYPE	EQU	TMB_TIME+4	;TMB TYPE:
			   		;TYPE 1= DRIVER OR TOD TIMEOUT.
					;TYPE 2= TASK PAUSE	EXPIRATION.
					;TYPE 3= EVENT FLAG	TO BE SET.
					;TYPE 4= TASK RESTART TIMER.
					;TYPE 5= OVERRIDE-PRIORITY TIMER.
					;TYPE 6= RESERVED
					;TYPE 7= RESERVED
					;TYPE 8= SVC TIMEOUT.
					;TYPE 9= DELAYED MESSAGES.
;
;   TYPE 1
;
TMB_UCB		EQU	TMB_TYPE  +2	;UCB OF	UNIT
TMB_SADR	EQU	TMB_UCB	  +2	;ADDRESS OF TIMEOUT ROUTINE
TMB_HTIME	EQU	TMB_SADR+6	;HIGH WORD, ABSOLUTE EXPIRATION TIME.
;
;   TYPE 2
;
TMB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
;
;   TYPE 3
;
TMB_EFGRP	EQU	TMB_TYPE  +1	;EVENT FLAG GROUP
;MB_TCB		EQU	TMB_EFGRP +1	;TCB OF	REQUESTOR
TMB_EFMSK	EQU	TMB_TCB	  +2	;EVENT FLAG MASK
;
;   TYPE 4
;
;MB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
;
;   TYPE 5
;
;MB_TCB		EQU	TMB_TYPE  +2	;TCB OF	REQUESTOR
TMB_OVPRI	EQU	TMB_TCB	  +2	;PRIORITY-OVERRIDE INCREMENT
TMB_BPRI	EQU	TMB_OVPRI +1	;OVERRIDE-PRIORITY BOUNDARY
TMB_OVTIME	EQU	TMB_BPRI  +1	;OVERRIDE TIME INTERVAL, MSEC.
;
;   TYPE 6
;
;   TYPE 7
;
;   NUMBER OF SVCS WITH	TIMEOUT:
;
TIMEOUT_SVC_NUM	EQU 6	    		;EQUAL NUMBER OF BITS DEFINED ABOVE.
;
;   TYPE 8
;
TMB_CSVC	EQU	TMB_TYPE  +1	;BIT CODED SVC WITH ACTIVE TIMEOUT
TMB_TJT		EQU	TMB_UCB		;TIMEOUT JUMP TABLE
TMB_QH		EQU	TMB_TJT   +2	;SPECIFIC QUEUE	HEADER
TMB_WB		EQU	TMB_QH	  +2	;SPECIFIC WAIT BLOCK
TMB_SSVC	EQU	TMB_WB	  +2	;TIMEOUT BITS DEFINED ABOVE.
TMB_NSVC	EQU	TMB_SSVC  +1	;SVC NUMBER BEFORE TIMEOUT.
TMB_STIME	EQU	TMB_NSVC  +3	;SVC SPECIFIC TIMEOUT VALUES.
TMB_SIZE	EQU	TMB_STIME +TIMEOUT_SVC_NUM*2 ;SIZE OF TMB IN BYTES.
;
;   TYPE 9
;
TMB_ALARM	EQU	TMB_TYPE  +2	;ALARM ROUTINE,	CALLED ON EXPIRATION
TMB_TIB		EQU	TMB_ALARM +2	;CORRESPONDING TIB
)FI

;
;   SRB:    S-STATE REQUEST BLOCK.
;
%IF(%RM3)THEN(			
SRB_LINK	EQU	0		;FORWARD LINK OR 0.
SRB_EAX		EQU	SRB_LINK +4	;CALLER'S EAX
SRB_ECX		EQU	SRB_EAX	 +4	;	      ECX
SRB_EDX		EQU	SRB_ECX	 +4	;	      EDX
SRB_EBX		EQU	SRB_EDX	 +4	;	      EBX
SRB_EBP		EQU	SRB_EBX	 +4	;	      EBP
SRB_ESI		EQU	SRB_EBP	 +4	;	      ESI
SRB_EDI		EQU	SRB_ESI	 +4	;	      EDI
SRB_ES		EQU	SRB_EDI	 +4	;	       ES
SRB_FS		EQU	SRB_ES	 +2	;	       FS
SRB_GS		EQU	SRB_FS	 +2	;	       GS
SRB_ADR		EQU	SRB_GS	 +2	;ADDRESS OF	S-STATE	ROUTINE
SRB_TCB		EQU	SRB_ADR	 +4	;RESERVED FOR BK-DRIVER
SRB_SIZE	EQU	SRB_TCB	 +4	;SIZE OF SRB IN BYTES.
)ELSE(
SRB_LINK	EQU	0		;FORWARD LINK OR 0.
SRB_EAX		EQU	SRB_LINK +2	;CALLER'S EAX
SRB_ECX		EQU	SRB_EAX	 +2	;	      ECX
SRB_EDX		EQU	SRB_ECX	 +2	;	      EDX
SRB_EBX		EQU	SRB_EDX	 +2	;	      EBX
SRB_EBP		EQU	SRB_EBX	 +2	;	      EBP
SRB_ESI		EQU	SRB_EBP	 +2	;	      ESI
SRB_EDI		EQU	SRB_ESI	 +2	;	      EDI
SRB_ES		EQU	SRB_EDI	 +2	;	       ES
SRB_FS		EQU	SRB_ES	 +2	;	       FS
SRB_GS		EQU	SRB_FS	 +2	;	       GS
SRB_ADR		EQU	SRB_GS	 +2	;ADDRESS OF	S-STATE	ROUTINE
SRB_TCB		EQU	SRB_ADR	 +2	;RESERVED FOR BK-DRIVER
SRB_SIZE	EQU	SRB_TCB	 +2	;SIZE OF SRB IN BYTES.
)FI

;
;   RCB:    RESTART CONTROL BLOCK.
;
%IF(%RM3)THEN(			
RCB_LINK	EQU	0		;FORWARD LINK OR 0.
RCB_PRI		EQU	RCB_LINK +4	;PRIORITY OF REQUEST AND REQUESTED TASK
RCB_CORD	EQU	RCB_PRI	 +1	;COORDINATION:
					;0=NO COORDINATION TO BE ENFORCED,
					;1=REQUESTOR WAITS TILL TARGET STARTS,
					;2=REQUESTOR WAITS TILL TARGET ENDS.
RCB_WTCB	EQU	RCB_CORD +1	;REQUESTOR'S TCB.
RCB_EAX		EQU	RCB_WTCB +4	;STARTUP EAX
RCB_EBX		EQU	RCB_EAX	 +4	;	 EBX
RCB_TCB		EQU	RCB_EBX	 +4	;TCB OF TASK TO BE STARTED.
RCB_PARAM	EQU	RCB_TCB	 +4+8	;START OF QCOPY	PARAMETER REGION
RCB_SIZE	EQU	SMR_SIZE -4	;SIZE OF RCB IN BYTES.
)ELSE(
RCB_LINK	EQU	0		;FORWARD LINK OR 0.
RCB_PRI		EQU	RCB_LINK +2	;PRIORITY OF REQUEST AND REQUESTED TASK
RCB_CORD	EQU	RCB_PRI	 +1	;COORDINATION:
					;0=NO COORDINATION TO BE ENFORCED,
					;1=REQUESTOR WAITS TILL TARGET STARTS,
					;2=REQUESTOR WAITS TILL TARGET ENDS.
RCB_WTCB	EQU	RCB_CORD +1	;REQUESTOR'S TCB.
RCB_EAX		EQU	RCB_WTCB +2	;STARTUP EAX
RCB_EBX		EQU	RCB_EAX	 +2	;	 EBX
RCB_TCB		EQU	RCB_EBX	 +2	;TCB OF TASK TO BE STARTED.
RCB_PARAM	EQU	16		;START OF QCOPY PARAMETER REGION
RCB_SIZE	EQU	SMR_SIZE	;SIZE OF RCB IN BYTES.
)FI
;
;   TIMEOUT BITS INDICATING THE	CORRESPONDING SVC:
;
TB_ALOC		EQU	00000001B
TB_CNTRL_TSF	EQU	00000010B
TB_LOOK		EQU	00000100B
TB_RECV		EQU	00001000B
TB_SEND		EQU	00010000B
TB_WEF		EQU	00100000B
;
;   TIB:    TIMER CONTROL BLOCK	(DELAYED MESSAGES)
;
%IF(%RM3)THEN(			
TIB_	STRUC				;TIMER CONTROL BLOCK:
TIB_LINK	DD ?			;NEXT TIB OR 0
TIB_PRIV	DB ?			;MAILBOX DATA:  
					;PRIORITY VALUE (ALSO KEY FOR LINKAGE)
TIB_PRIT	DB ?			;PRIORITY TYPE
TIB_COOR	DB ?			;COORDINATION (OVERFLOW FLAG OPTION)
TIB_MBXID	DB ?			;MAILBOX ID
TIB_TCB		DD ?			;SENDER'S TCB
TIB_P1		DD ?			;PHYSICAL MESSAGE
TIB_P2		DD ?			;	"
TIB_P3		DD ?			;	"
TIB_STS		DB ?			;TIMER STATUS
TIB_RESERVED	DB 3 DUP(?)		;RESERVED FOR ALIGNMENT AND EXPANSION
TIB_TIMID	DD ?			;TIMER ID (UNIQUE NUMBER)
TIB_MBX		DD ?			;CORRESPONDING MAILBOX CONTROL BLOCK
TIB_MMB		DD ?			;CORRESPONDING MAILED MESSAGE BLOCK
TIB_TMB		DD ?			;USED TIMER	MONITOR	BLOCK
TIB_	ENDS
)ELSE(
TIB_	STRUC				;TIMER CONTROL BLOCK:
TIB_LINK	DW ?			;NEXT TIB OR 0
TIB_PRIV	DB ?			;MAILBOX DATA:  
					;PRIORITY VALUE (ALSO KEY FOR LINKAGE)
TIB_PRIT	DB ?			;PRIORITY TYPE
TIB_COOR	DB ?			;COORDINATION (OVERFLOW FLAG OPTION)
TIB_MBXID	DB ?			;MAILBOX ID
TIB_TCB		DW ?			;SENDER'S TCB
TIB_P1		DW ?			;PHYSICAL MESSAGE
TIB_P2		DW ?			;	"
TIB_P3		DW ?			;	"
TIB_P4		DW ?			;	"
TIB_P5		DW ?			;	"
TIB_STS		DB ?			;TIMER STATUS
TIB_RESERVED	DB 1 DUP(?)		;RESERVED FOR ALIGNMENT AND EXPANSION
TIB_TIMID	DD ?			;TIMER ID (UNIQUE NUMBER)
TIB_MBX		DW ?			;CORRESPONDING MAILBOX CONTROL BLOCK
TIB_MMB		DW ?			;CORRESPONDING MAILED MESSAGE BLOCK
TIB_TMB		DW ?			;USED TIMER	MONITOR	BLOCK
TIB_	ENDS
)FI

TIB_SIZE    EQU	SIZE TIB_   ;SIZE IN BYTES

TI_STRT		EQU 1			;VALUES	FOR TIMER STATUS: TIMER STARTED
TI_SEND		EQU 2			;		          MESSAGE SENT

;
;	POOL INFO STRUCT FOR RmMemPoolInfo
;	
PIS	STRUC		;PARAMETER RmMemPoolInfo FLAT
PIS_POOL_SIZE		DD ?	;TOTAL POOL SIZE
PIS_AVAIL_MEM_SIZE	DD ?	;available memory
PIS_MAX_BLOCK_SIZE	DD ?	;SIZE OF BIGGEST BLOCK
PIS_RESERVED		DD 5 DUP (?)
PIS	ENDS

;
;	SYSTEM CONTROL BLOCK STRUCTURE
;	
%IF(%RM3)THEN(			
SYSB_COMMONSIZE	EQU (16+16+128+6+2)	;SIZE OF SYSB UP TO BOOTDRIVE
SYSB_S	STRUC				;SYSTEM CONTROL BLOCK (SYSB)
VERSION		DB  6 DUP (?)		;RMOS VERSION NUMBER
PROCTYPE	DW  ?			;PROCESSOR TYPE
SYSTEMTYPE	DW  ?			;SYSTEM TYPE (RMOS2, RMOS3, R4WIN)
RES1		DW  ?			;RESERVED
RESERVED	DD  ?			;RESERVED
STATNAME	DB  16	DUP(?)		;STATIONNAME
BOOTFNAME	DB  128	DUP(?)		;FILESPEC OF LOADED SYSTEM
BOOTNODE	DB  6	DUP(?)		;6 BYTES LAN ADDRESS OF	BOOT SERVER
BOOTDRIVE	DB  ?			;DRIVE FROM WHICH SYSTEM WAS LOADED
RES2		DB  ?			;RESERVED

RAM_SIZE	DD  ?			;RAMSIZE (GOT FROM RC_RAM_SIZE)
SMR_MAX		DD  ?			;MAXIMUM NUMBER OF SMRs
SMR_USED	DD  ?			;ACTUAL NUMBER OF USED SMRs
SMR_AVAIL	DD  ?			;AVAILABLE SMRs
OUT_OF_SMR_COUNT DD  ?			;NUMBER OF SMR BOUND REACHED
FL_ER_SEL	DW  ?			;FLAT SELECTOR FOR CODE
FL_RW_SEL	DW  ?			;FLAT SELECTOR FOR DATA

RATE_MSEC	DW  ?			;RMOS SYSTEMTAKT IN MS
RATE_USEC	DD  ?			;RMOS SYSTEMTAKT IN USEC
PIT_COUNT	DD  ?			;TIMERTICKS BETWEEN TWO TIMERINTERRUPTS
TIMER_INT	DW  ?			;INTERRUPT NUMBER FOR TIMER

ISSUE_EOI_ENTRY	DD  ?			;ISSUE EOI HAS TO BE NEAR
PIC_COUNT	DB  ?			;NUMBER	OF INTERRUPTS
PIC_BASE	DB  8 DUP(?)		;VECTOR NUMBERS ASSIGNED TO PIC 1 to 8
PIC_MASK	DB  8 DUP(?)		;PIC MASKS SET FOR PIC 1 TO 8
RES3		DB  3 DUP(?)		;RESERVED

SET_PIC_MASK	DP  ?			;SET PIC MASK
RES4		DW  ?			;RESERVED
INIT_PIT	DP  ?			;INIT TIMER
RES5		DW  ?			;RESERVED
SET_RTC_ENTRY	DP  ?			;SET CMOS CLOCK
RES6		DW  ?			;RESERVED
GET_RTC_ENTRY	DP  ?			;GET CMOS CLOCK
RES7		DW  ?			;RESERVED
PUTCHAR_ENTRY	DP  ?			;PUTCHAR FOR X_NUCPRINTF
SYSB_S	ENDS

)ELSE(            

SYSB_COMMONSIZE	EQU (16+16+128+6+2)	;SIZE OF SYSB UP TO BOOTDRIVE
SYSB_S	STRUC				;SYSTEM CONTROL BLOCK (SYSB)
VERSION		DB  6 DUP (?)		;RMOS VERSION NUMBER
PROCTYPE	DW  ?			;PROCESSOR TYPE
SYSTEMTYPE	DW  ?			;SYSTEM TYPE (RMOS2, RMOS3, R4WIN)
RES1		DW  ?			;RESERVED
RESERVED	DD  ?			;RESERVED
STATNAME	DB  16	DUP(?)		;STATIONNAME
BOOTFNAME	DB  128	DUP(?)		;FILESPEC OF LOADED SYSTEM
BOOTNODE	DB  6	DUP(?)		;6 BYTES LAN ADDRESS OF	BOOT SERVER
BOOTDRIVE	DB  ?			;DRIVE FROM WHICH SYSTEM WAS LOADED
RES2		DB  ?			;RESERVED

RAM_SIZE	DD  ?			;RAMSIZE (GOT FROM RC_RAM_SIZE)
SMR_MAX		DW  ?			;MAXIMUM NUMBER OF SMRs
SMR_USED	DW  ?			;ACTUAL NUMBER OF USED SMRs
SMR_AVAIL	DW  ?			;AVAILABLE SMRs
OUT_OF_SMR_COUNT DW  ?			;NUMBER OF SMR BOUND REACHED

RATE_MSEC	DW  ?			;RMOS SYSTEMTAKT IN MS
RATE_USEC	DD  ?			;RMOS SYSTEMTAKT IN USEC
PIT_COUNT	DD  ?			;TIMERTICKS BETWEEN TWO TIMERINTERRUPTS
TIMER_INT	DW  ?			;INTERRUPT NUMBER FOR TIMER

ISSUE_EOI_ENTRY	DD  ?			;ISSUE EOI HAS TO BE NEAR
PIC_COUNT	DB  ?			;NUMBER	OF INTERRUPTS
PIC_BASE	DB  8 DUP(?)		;VECTOR NUMBERS ASSIGNED TO PIC 1 to 8
PIC_MASK	DB  8 DUP(?)		;PIC MASKS SET FOR PIC 1 TO 8
RES3		DB  ?			;RESERVED

SET_PIC_MASK	DD  ?			;SET PIC MASK
INIT_PIT	DD  ?			;INIT TIMER
SET_RTC_ENTRY	DD  ?			;SET CMOS CLOCK
GET_RTC_ENTRY	DD  ?			;GET CMOS CLOCK
PUTCHAR_ENTRY	DD  ?			;PUTCHAR FOR X_NUCPRINTF
SYSB_S	ENDS
)FI
;
;   SIZE OF AN ALLOCATED NPX SAVE AREA.
;
%IF(%RM3)THEN(
NPX_SIZE    EQU	108	;SIZE IN BYTES.
)ELSE(
NPX_SIZE    EQU	94	;SIZE IN BYTES.
)FI
CR0_MP		EQU	00000010B	;MATH PRESENT BIT
CR0_EM		EQU	00000100B	;MATH EMULATION BIT
CR0_TS		EQU	00001000B	;TASK SWITCH BIT

;
;   EQUATES TO THE STACK OF AN INTERRUPTED OR SUSPENDED	TASK:
;
%IF(%RM3)THEN(			
STK_DS		EQU	0
STK_GS		EQU	STK_DS	  +4
STK_FS		EQU	STK_GS	  +4
STK_ES		EQU	STK_FS	  +4
STK_EDI		EQU	STK_ES	  +4
STK_ESI		EQU	STK_EDI	  +4
STK_EBP		EQU	STK_ESI	  +4
STK_ESP		EQU	STK_EBP	  +4
STK_EBX		EQU	STK_ESP	  +4
STK_EDX		EQU	STK_EBX	  +4
STK_ECX		EQU	STK_EDX	  +4
STK_EAX		EQU	STK_ECX	  +4
STK_EIP		EQU	STK_EAX	  +4	;SAVED BY INTERRUPT OR SVC INTERFACE.
STK_CS		EQU	STK_EIP	  +4	; "
STK_EFL		EQU	STK_CS	  +4	; "
STK_TEAX1	EQU	STK_EFL	  +4	;FIRST COPY:  TCD_EAX,
STK_TEBX1	EQU	STK_TEAX1 +4	;	      TCD_EBX.
STK_TEAX2	EQU	STK_TEBX1 +4	;SECOND	COPY: TCD_EAX,
STK_TEBX2	EQU	STK_TEAX2 +4	;	      TCD_EBX.
STK_SDB		EQU	STK_EFL	  +4		;SVC TYPE 1:  SDB POINTER.

INIT_STK_SIZE	EQU STK_TEBX2 +4	;SIZE OF INITIAL PART.
)ELSE(
STK_DS		EQU	0
STK_ES		EQU	STK_DS	  +2
STK_EDI		EQU	STK_ES	  +2
STK_ESI		EQU	STK_EDI	  +2
STK_EBP		EQU	STK_ESI	  +2
STK_ESP		EQU	STK_EBP	  +2
STK_EBX		EQU	STK_ESP	  +2
STK_EDX		EQU	STK_EBX	  +2
STK_ECX		EQU	STK_EDX	  +2
STK_EAX		EQU	STK_ECX	  +2
STK_EIP		EQU	STK_EAX	  +2	;SAVED BY INTERRUPT OR SVC INTERFACE.
STK_CS		EQU	STK_EIP	  +2	; "
STK_EFL		EQU	STK_CS	  +2	; "
STK_TEAX1	EQU	STK_EFL	  +2	;FIRST COPY:  TCD_EAX,
STK_TEBX1	EQU	STK_TEAX1 +2	;	      TCD_EBX.
STK_TEAX2	EQU	STK_TEBX1 +2	;SECOND	COPY: TCD_EAX,
STK_TEBX2	EQU	STK_TEAX2 +2	;	      TCD_EBX.
STK_SDB		EQU	STK_EFL	  +2		;SVC TYPE 1:  SDB POINTER.

INIT_STK_SIZE	EQU	STK_TEBX2 +2	;SIZE OF INITIAL PART.
)FI

;
;   STRUCTUR FOR EXCEPTION DATA
;
EXCEPTION_DATA	STRUC
EXCEP_STATE	DB	?
EXCEP_TASK_ID	DW	?
EXCEP_SVC_NO	DW	?
EXCEP_INTR_NO	DB	?
EXCEP_ERR_CODE	DD	?
EXCEP_EFLAG	DD	?
EXCEP_EIP	DD	?
EXCEP_CS	DW	?
EXCEP_EAX	DD	?
EXCEP_EBX	DD	?
EXCEP_ECX	DD	?
EXCEP_EDX	DD	?
EXCEP_ESI	DD	?
EXCEP_EDI	DD	?
EXCEP_EBP	DD	?
EXCEP_ESP	DD	?
EXCEP_SS	DW	?
EXCEP_DS	DW	?
EXCEP_ES	DW	?
%IF(%RM3)THEN(
EXCEP_FS	DW	?
EXCEP_GS	DW	?
)FI
EXCEPTION_DATA	ENDS

;
;   SYMBOLS USED FOR DYNAMIC RESOURCES:
;
%IF(%RM3)THEN(			
IL_DYN		EQU	000000000H	;"IN LIST"-IDENTIFIER.
NIL_DYN		EQU	0FFFFFFFFH	;"NOT IN LIST"-IDENTIFIER
DEV_DORMANT	EQU	0FFFFFFFFH	;DEVICE DRIVER DORMANT.
)ELSE(
IL_DYN		EQU	00000H		;"IN LIST"-IDENTIFIER.
NIL_DYN		EQU	0FFFFH		;"NOT IN LIST"-IDENTIFIER
DEV_DORMANT	EQU	0FFFFH		;DEVICE DRIVER DORMANT.
)FI
;
;   DIRECTORY CONTROL BLOCK:
;
DIR_STRING	EQU	0		;ASCII STRING.
DIR_KIND	EQU	DIR_STRING+13	;KIND OF RESOURCE.
DIR_ID		EQU	DIR_KIND  +1	;ID OF RESOURCE.
DIR_SIZE	EQU	DIR_ID	  +2	;SIZE OF DIRECTORY CONTROL BLOCK.
;
;   DIRECTORY WAIT BLOCK:
;
%IF(%RM3)THEN(			
DWB_LINK	EQU	0		;FORWARD LINK OR 0.
DWB_PRI		EQU	DWB_LINK +4	;WAIT BLOCK	PRIORITY.
DWB_TCB		EQU	DWB_PRI	 +2	;TCB ADDRESS OF REQUESTOR.	
DWB_SPTR	EQU	DWB_TCB	 +4	;FAR POINTER TO SEARCHED ASCII STRING.
DWB_BPTR	EQU	DWB_SPTR +6	;FAR POINTER TO USER BUFFER.
DWB_SIZE	EQU	DWB_BPTR +6	;SIZE OF DIRECTORY WAIT BLOCK.
)ELSE(
DWB_LINK	EQU	0		;FORWARD LINK OR 0.
DWB_PRI		EQU	DWB_LINK +2	;WAIT BLOCK	PRIORITY.
DWB_TCB		EQU	DWB_PRI	 +2	;TCB ADDRESS OF REQUESTOR.	
DWB_SPTR	EQU	DWB_TCB	 +2	;FAR POINTER TO SEARCHED ASCII STRING.
DWB_BPTR	EQU	DWB_SPTR +4	;FAR POINTER TO USER BUFFER.
DWB_SIZE	EQU	DWB_BPTR +4	;SIZE OF DIRECTORY WAIT BLOCK.
)FI
;
;   VALUES FOR KIND OF RESOURCE	IN DIRECTORY:
;
K_TASK		EQU	00H		;IDENTIFIES: TASK.
K_DEV_DRIVER	EQU	01H		;	DEVICE DRIVER.
K_MEM_POOL	EQU	02H		;	MEMORY POOL.
K_SEMAPHORE	EQU	03H		;	SEMAPHORE.
K_GLOBAL_EFLAG	EQU	04H		;	GLOBAL EVENT FLAG GROUP.
K_CNTRL_PROG	EQU	05H		;	CONTROLLED PROGRAM.
K_LOCAL_MBOX	EQU	06H		;	LOCAL MAILBOX.
K_MISC		EQU	07H		;	RESERVED
K_USER		EQU	08H		;	RESERVED
K_DISCRETE	EQU	09H		;	DISCRETE BYTE GROUP FOR I/O.
K_DEV_UNIT	EQU	0AH		;	DEVICE UNIT.
K_MESSAGE	EQU	0BH		;	MESSAGE QUEUE.
K_SYSTEM	EQU	0CH		;	SYSTEM.
;   REST OF VALUES RESERVED.
MAX_KIND	EQU	0CH		;MAXIMAL VALID VALUE.

K_ALL		EQU	0FFH		;LIST ALL KINDS.

%IF(%RM3)THEN(			
;		  
;   MISCELLANEOUS USEFUL SYMBOLS:
;
GDT_ALIAS	EQU	1*8		;ALIASES FOR GDT AND IDT
IDT_ALIAS	EQU	2*8
INT_ACCESS	EQU	10001110B	;ACCESS BYTE FOR INTERRUPT DESCRIPTOR
EXECUTE_RIGHTS	EQU	9AH		;EXECUTE AND READ
RES_SLOTS	EQU	8		;RESERVED ENTRIES AT BEGINNING OF GDT
)ELSE(

;	HOOK TABLE INDICES:
;
XH_CREATE_I	EQU	0
XH_DELTSK_I	EQU	1
XH_TSKSWT_OUT_I	EQU	2
XH_TSKSWT_IN_I	EQU	3
XH_SVC_I	EQU	4
XH_RIO_START_I	EQU	5
XH_RIO_END_I	EQU	6
XH_SCHDLR_I	EQU	7
XH_ISTATE_I	EQU	8
XH_SSTATE_I	EQU	9

X_HOOK_TAB_LEN	EQU	10	;NUMBER OF INDICES ABOVE
)FI

MAX_SVC_NUM	EQU	80H		;SO MANY SVCS
MAX_SVC_PARAM	EQU	TCB_TCD		;SO MANY PARAMETERS ARE ALLOWED IN A SVC
SET_SVC_NUM	EQU	1DH		;SVC # OF RmSetSVC
PARM_ERR	EQU	0080H		;(SF) PARAMETER	ERROR IN SDB.
SVC_FAILED	EQU	0040H		;(ZF) SVC PROCESSING ABORTED.
FLAG_CF		EQU	0001H		;(CF) GENERAL-PURPOSE INDICATOR.
FLAG_OF		EQU	0800H		;(OF) FOR CERTAIN SPECIFIC SVCS.
INIT_FLAGS	EQU	0200H		;(IF) INTERRUPTS ON.
LINK_END	EQU	0		;END OF POOL FREE BLOCK LIST.
RM_IRQ_TAG	EQU	8000H		;FLAG FOR SETING AN IRQ	(IRQ+PICBASE) OR AN INTERRUPT
MAX_SMR		EQU	3		;MAXIMAL SMR NUMBER PER	SVC
YES		EQU	1
NO		EQU	0
TRUE		EQU	YES
FALSE		EQU	NO
RM_USER_INT	EQU	245

;		  
;   CONFIGURATION STATE (X_CFGSTATE)
;

RESET_ERROR	EQU	0FFFFH		;ERROR OCCURED IN RESET_OS
RESET_STATE	EQU	1		;OS AFTER RMRESETOS
INIT_STATE	EQU	2		;OS AFTER RMINITOS
RUN_STATE	EQU	3		;OS AFTER RMRUNOS ON THE FLY

;		  
;   SYSTEM TYPE IN SYSB (X_SYSB.SYSTEMTYPE)
;

RM_SYSTEM_RMOS2	EQU	2
RM_SYSTEM_RMOS3	EQU	3
RM_SYSTEM_R4WIN	EQU	4

;		  
;   MISCELLANEOUS DEFINES
;

RM_CR_INHERITANCE 	 EQU   1000H
RM_CR_REMOVE_INHERITANCE EQU   2000H
RM_CR_ENDTASK     	 EQU   0001H
RM_CR_DELETETASK  	 EQU   0004H

;
;   ERROR CODES
;
;FLAGS FOR OLD ERRORS
IPARM_ERR	EQU	8000H		;(SF) PARAMETER ERROR IN SDB.
ISVC_FAILED	EQU	4000H		;(ZF) SVC PROCESSING ABORTED.
IFLAG_OF	EQU	2000H		;(OF) FOR CERTAIN SPECIFIC SVCS.
IFLAG_CF	EQU	1000H		;(CF) GENERAL-PURPOSE INDICATOR.

RM_OK				EQU 0
; SVC MESSAGECODES
RM_ERROR_OUT_OF_RANGE		EQU -265
RM_ENTRY_REMOVED		EQU -263
RM_TASK_WAITING			EQU -262
RM_PRI_NOT_CHANGED		EQU -261
RM_FLAG_RESET			EQU -260
RM_FLAG_SET			EQU -259
RM_FLAG_ALREADY_SET		EQU -258
RM_TASK_RESUMED			EQU -256

; SVC ERRORCODES
RM_SYSTEMERROR			EQU 1
RM_PARAMETER_ERROR		EQU 2
RM_OUT_OF_MEMORY		EQU 3
RM_GOT_TIMEOUT			EQU 4
RM_INVALID_DESCRIPTOR		EQU 5
RM_INVALID_SEGMENTLENGTH	EQU 6
RM_TASK_DORMANT			EQU 7
						; 8 not used
RM_GDT_FULL			EQU 9
RM_INVALID_NULLPOINTER		EQU 10
RM_OUT_OF_BYTEGROUPS		EQU 11
RM_OUT_OF_FLAGGROUPS		EQU 12
RM_OUT_OF_MEMORYPOOLS		EQU 13
RM_HEAP_NOT_REDEFINEABLE	EQU 14
RM_OUT_OF_MAILBOXES		EQU 15
RM_OUT_OF_SEMAPHORES		EQU 16
RM_INVALID_MEMORYBLOCK		EQU 17
RM_RESOURCE_BUSY		EQU 18
						; 19 not used
RM_TASK_NOT_DORMANT		EQU 20
RM_INVALID_SELECTOR		EQU 21
RM_INVALID_TASK_STATE		EQU 22
RM_RESOURCE_NOT_AVAILABLE	EQU 23
						; 24 not used
RM_MEMORY_ALREADY_USED		EQU 25
RM_TASK_NOT_PAUSED		EQU 26
RM_BOUND_REACHED		EQU 27
RM_BREAKPOINT_ID_ALREADY_USED	EQU 28
RM_BREAKPOINT_ALREADY_SET	EQU 29
RM_TASK_NOT_READY		EQU 30
RM_TASK_NOT_IN_BP_CONTEXT 	EQU 31
RM_TASK_NOT_IN_RTE_HALT		EQU 32
RM_SVC_NOT_CONFIGURED		EQU 33
						; 34 not used
RM_INVALID_TYPE			EQU 35
RM_INVALID_ID			EQU 36
RM_INVALID_STRING		EQU 37
RM_INVALID_SIZE			EQU 38
RM_INVALID_OFFSET		EQU 39
						; 40 not used
RM_INVALID_IRQ_NUMBER		EQU 41
RM_INVALID_POINTER		EQU 42
RM_NO_MESSAGE			EQU 43
RM_INVALID_FUNCTION		EQU 44
RM_ALL_DEBUGREGISTERS_USED	EQU 45
RM_NOT_HALTABLE			EQU 46
RM_IS_NOT_CATALOGED		EQU 47
RM_IS_ALREADY_CATALOGED		EQU 48
RM_TASK_KILLED			EQU 49
RM_LINKTIMER_FULL		EQU 50
RM_INVALID_POOL_CFG		EQU 51
RM_INVALID_CFG_STATE		EQU 52
RM_NO_EOI			EQU 53
RM_NO_INIT_TIMER		EQU 54
RM_SYNTAX_ERROR			EQU 55
RM_INVALID_INTERRUPT_NUMBER	EQU 56
RM_TEST_NOT_OK			EQU 57
RM_QUEUE_NOT_EXIST		EQU 58
RM_QUEUE_EXIST			EQU 59
RM_INVALID_TASK_ENTRY		EQU 60
RM_LINE_TOO_LONG		EQU 61
RM_INVALID_SECTION_DECLARATION	EQU 62
RM_UNKNOWN_SECTION		EQU 63
RM_STATEMENT_OUTSIDE_SECTION	EQU 64
RM_INVALID_SECTION_NAME		EQU 65
RM_INVALID_DCD_SEGMENT		EQU 66

RM_CATALOG_EXCEEDED		EQU 100

%IF(%RM3)THEN(			
_GPTR_	STRUC		;GENERIC POINTER:
GPTR		DP ?
_GPTR_	ENDS
)ELSE(
_GPTR_	STRUC		;GENERIC POINTER:
GPTR		DD ?
_GPTR_	ENDS
)FI

%IF(%RM3)THEN(			
_PTR_	STRUC		;LAYOUT	OF A POINTER:
OFS		DD ?
SEL		DW ?
_PTR_	ENDS
)ELSE(
_PTR_	STRUC		;LAYOUT	OF A POINTER:
OFS		DW ?
SEL		DW ?
_PTR_	ENDS
)FI

_WORD_	STRUC		;LAYOUT	OF A WORD:
LOBYT		DB ?
HIBYT		DB ?
_WORD_	ENDS

_DWORD_	STRUC		;LAYOUT	OF A DWORD:
LOWRD		DW ?
HIWRD		DW ?
_DWORD_	ENDS

_QWORD_	STRUC		;LAYOUT	OF A QWORD:
LODWRD		DD ?
HIDWRD		DD ?
_QWORD_	ENDS

$RESTORE
